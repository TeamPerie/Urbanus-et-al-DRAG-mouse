---
title: "Analysis of Ageing of Hematopoietic Stem and Progenitor Cells by scRNAseq"
output: html_document
author: Jason Cosgrove (jason.cosgrove@curie.fr) 
---

<style type="text/css">

body{ /* Normal  */
      font-size: 12px;
  }
td {  /* Table  */
  font-size: 8px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>


In this study we would like to understand how the LSK (HSPC) comparment changes as a function of age. In this setting LSKs were sorted from bone marrow suspensions at 27 weeks (2 mice), 55 weeks (2 mice), and 75-79 weeks (2 mice). 


Cells from each condition were sequenced on the 10X Genomics platform, a droplet based approach to isolate single-cells for sequencing. As described in AlJahani et al (2018): "Droplet-based single-cell gene expression approaches use microfluidic chips to isolate single cells along with single beads in oil-encapsulated droplets, using microfluidics to bring oil, beads, and cell suspensions together in such a way that each droplet contains at most a single cell.20 The beads are coated with DNA oligos that are composed of a poly(T) tail at the 3′ end for the capture of cellular mRNAs, and at the 5′ end both a cell barcode that is identical for every oligo coating an individual bead and a library of individual unique molecular identifier (UMI) barcodes of high diversity, each UMI different for every oligo on the bead. The transcripts from each individual cell captured and labeled by the DNA oligos attached to a bead within the droplets are reverse transcribed, amplified with PCR, and sequenced using a high-throughput platform, after breaking and pooling droplet contents. The resulting sequences are aligned to a reference genome in order to annotate each transcript with its gene name. The cell barcodes on the aligned sequences allow for the computational linking of each gene transcript to its cell of origin. The number of copies of individual gene transcripts expressed in each individual cell is tallied using the UMIs, allowing the assembly of digital gene expression matrices (DGEs),  are tables of cell barcodes and gene counts."


```{r, setup, message = FALSE, warning = FALSE,echo = FALSE}  

knitr::opts_knit$set(root.dir = '/Users/jasoncosgrove/Dropbox (Team_Perie)/Jason/Experiments/Dry_Lab/JCB18_DRAG_forUrbanus_et_al')

knitr::opts_chunk$set(fig.width=12, fig.height=12)

``` 


# Section 1: Data QC 

## Step 1: Prepare the workspace loading the appropriate packages
 
```{r initialiseWorkspace, message = FALSE, warning = FALSE}  
#clear the workspace
rm(list=ls())

setwd('/Users/jasoncosgrove/Dropbox (Team_Perie)/Jason/Experiments/Dry_Lab/JCB18_DRAG_forUrbanus_et_al')

#load in the appropriate packages
library(Seurat)
library(scran)
library(org.Mm.eg.db)
library(clustree)
library(dplyr)
library(ggpubr)
library(destiny)
library(RANN)
library(destiny)
library(enrichR)
source("code/helper_methods.R")

#set the seed for reproducibility of the analysis
set.seed(12345)



``` 

## Step 2. load the 10X expression matrices, preprocessed by the CellRanger pipeline. 

```{r load_data, message = FALSE, warning = FALSE,eval = F}  

#12 month timepoint we have 2 mice that were processed on the same day
exp2.454 <- Read10X(data.dir= "inputs/exp2/454/") 
exp2.534 <- Read10X(data.dir= "inputs/exp2/534/") 

#18 month timepoint, we have 2 mice that were processed on different days
exp4 <- Read10X(data.dir= "inputs/exp4/") 
exp5 <- Read10X(data.dir= "inputs/exp5/") 

#new 6 month timepoints
exp6.m1 <- Read10X(data.dir= "inputs/exp6/count_M85/") 
exp6.m2 <- Read10X(data.dir= "inputs/exp6/count_M88/") 

```


## Step 3. Create seurat objects from the data and perform preprocessing

To assess the quality of the data we assess the library sizes, numbers of genes expressed and mitochondrial content per cell. Cells  have very high library sizes or relative to other cells in the data may represent doublet cells and so are filtered out. Cells with very low library sizes are typically because of poor capture quality pontentially due to cell death, premature rupture, or capture of random mRNA escaping from cells, consequently cells with low library sizes are also filtered out from downstream analyses. 

Another important QC metric is mitochondrial content. As discussed in AlJanahi et al (2018) "High numbers of mitochondrial transcripts are indicators of cell stress, and therefore cells with elevated mitochondrial gene expression are often not included in the analysis, because most experiments will not benefit from clustering cells based on stress levels. However, just as with number of transcripts, this parameter is highly dependent on the tissue type and the questions being investigated. For example, 30% of total mRNA in the heart is mitochondrial due to high energy needs of cardiomyocytes, compared with 5% or less in tissues with low energy demands. For instance, 30% mitochondrial mRNA is representative of a healthy heart muscle cell, but would represent a stressed lymphocyte."

```{r makeSeuratObjects, message = FALSE, warning = FALSE,eval = F}  


exp2.454.sobj <- CreateSeuratObject(counts = exp2.454, min.cells = 200, 
                                    min.features = 500,project = "mo12_m454")

exp2.534.sobj <- CreateSeuratObject(counts = exp2.534, min.cells = 200, 
                                    min.features = 500,project = "mo12_m534")

exp4.sobj <- CreateSeuratObject(counts = exp4, min.cells = 200, 
                                min.features = 500,project = "mo18_m1")

exp5.sobj <- CreateSeuratObject(counts = exp5, min.cells = 200, 
                                min.features = 500,project = "mo18_m2")

exp6.m1.sobj <- CreateSeuratObject(counts = exp6.m1, min.cells = 200, 
                                min.features = 500,project = "mo06_m1")

exp6.m2.sobj <- CreateSeuratObject(counts = exp6.m2, min.cells = 200, 
                                min.features = 500,project = "mo06_m2")




exp2.454.sobj <- preProcessDataset(exp2.454.sobj,50000,15)
exp2.534.sobj <- preProcessDataset(exp2.534.sobj,20000,20)
#this dataset has far more cells than any other and may dominate the analysis, 
# we downsample the numbers of cells in this dataset to avoid this effect. 
exp2.534.sobj <- subset(x = exp2.534.sobj, downsample = 2500 )


exp4.sobj <- preProcessDataset(exp4.sobj,50000,20)
exp5.sobj <- preProcessDataset(exp5.sobj,50000,15)

exp6.m1.sobj[["percent.mt"]] <- PercentageFeatureSet(exp6.m1.sobj, pattern = "^mt-")
VlnPlot(exp6.m1.sobj, c("nFeature_RNA","nCount_RNA","percent.mt"))
exp6.m1.sobj <- preProcessDataset(exp6.m1.sobj,50000,15)

exp6.m2.sobj[["percent.mt"]] <- PercentageFeatureSet(exp6.m2.sobj, pattern = "^mt-")
VlnPlot(exp6.m2.sobj, c("nFeature_RNA","nCount_RNA","percent.mt"))
exp6.m2.sobj <- preProcessDataset(exp6.m2.sobj,50000,15)

```




## Step 4. Normalise the data and find variably expressed genes

When analyzing sequencing data, normalization to eliminate batch effects is crucial if multiple sequencing runs are to be compared with each other. These batch effects can be caused by often unavoidable technical variations such as the duration samples were kept on ice, number of freeze-thaw cycles, method of RNA isolation, sequencing depth, etc.

An additional consideration is that droplet-based sequencing in addition consists of thousands of individual cell experiments, hence cell-specific biases must also be considered when normalizing, in order to be able to compare the expression of one cell to another.  A notable cell-specific bias is caused by mRNA capture efficiency, where the mRNA molecules are not captured by the bead at the same proportion in all droplets. As individual cells are not all of the same type a key consideration is how to retain cell to cell variability while eliminating technical noise. To normalise our data we use  the default seurat method. For the default method feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. This is then natural-log transformed using log1p. 


To find variably expressed genes of interest to take forward for further analysis we use Seurats vst method. Briefly, this approach models the relationship between log mean expression and log variance using local polynomial regression. The features values are then standardized using the observed mean and predicted variance, with the final variance value calculated on the standardized values. 

```{r normalise_data, message = FALSE, warning = FALSE,eval = F}  

dataset.list <- c(exp6.m1.sobj,exp6.m2.sobj,exp2.454.sobj, exp2.534.sobj, 
                  exp4.sobj,exp5.sobj)

for (i in 1:length(dataset.list)) {
    dataset.list[[i]] <- NormalizeData(dataset.list[[i]], verbose = FALSE)
    dataset.list[[i]] <- FindVariableFeatures(dataset.list[[i]], selection.method = "vst", nfeatures =2000, verbose = FALSE)
}


```

## Step 5. Integrate the two datasets

The joint analysis of two or more single-cell datasets poses unique challenges. In particular, identifying cell populations that are present across multiple datasets can be problematic under standard workflows. Seurat v4 includes a set of methods to match (or ‘align’) shared cell populations across datasets. These methods first identify cross-dataset pairs of cells that are in a matched biological state (‘anchors’), can be used both to correct for technical differences between datasets (i.e. batch effect correction), and to perform comparative scRNA-seq analysis of across experimental conditions.


```{r integrate_data, message = FALSE, warning = FALSE,eval = F}  

features <- SelectIntegrationFeatures(object.list = dataset.list,nfeatures = 2000)
dataset.anchors <- FindIntegrationAnchors(object.list = dataset.list,anchor.features = features, dims = 1:15)
dataset.integrated <- IntegrateData(anchorset = dataset.anchors, dims = 1:15)

DefaultAssay(dataset.integrated) <- "integrated"
VlnPlot(dataset.integrated, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)


```



## Step 6. Add metadata about the age of each sample

In this analysis we want to compare datasets across timepoints, to facilitate this analysis we create a new variable
timepoint

```{r timepointMetaData, message = FALSE, warning = FALSE,eval = F} 

timepoint <- dataset.integrated@meta.data$orig.ident

timepoint[timepoint == "mo06_m1"] <- "mo06"
timepoint[timepoint == "mo06_m2"] <- "mo06"
timepoint[timepoint == "mo12_m454"] <- "mo12"
timepoint[timepoint == "mo12_m534"] <- "mo12"
timepoint[timepoint == "mo18_m1"] <- "mo18"
timepoint[timepoint == "mo18_m2"] <- "mo18"

dataset.integrated@meta.data$timepoint <- as.factor(timepoint)

```

## Step 7. Perform CellCycle annotation

To assign a cell cycle phase to each cell, we use the cyclone method in the R package scran. In this scheme, a supervised learning approach was used to identify pairs of markers for each cell cycle phase. A G1 marker pair would comprise a gene with high expression in G1 relative to other phases, while the second gene would be lower in G1 relative to all other phases. To classify cell cycle phase on a new dataset, cyclone calculates the proportion of all marker pairs for  the expression of the first gene is higher than the second gene. A high proportion then suggests that the cell belongs to a given cell cycle phase. 

```{r annotateCellCycle, message = FALSE, warning = FALSE,eval = F}  

dataset.integrated <- runCellCycleAnnotation(dataset.integrated)
plotCellCycleResults(dataset.integrated)

```


## Step 8. Linear Dimensionality Reduction

We perform dimensionality reduction on variably expressed genes using both principle component analysis, an approach to find the linear combination of genes that are the greatest source of variance in the data.

```{r dimension_reduction, message = FALSE, warning = FALSE,eval = F}  


#first lets run PCA on the data
dataset.integrated <- ScaleData(dataset.integrated, verbose = FALSE)
dataset.integrated <- RunPCA(dataset.integrated, npcs = 30, verbose = FALSE)

ElbowPlot(dataset.integrated,ndims = 30)
VizDimLoadings(dataset.integrated, dims = 1:4, reduction = "pca",nfeatures = 20)

#as we can see on our PCA plot we have a small subset of outliers, lets see if this is due  a technical factor such as cell cycle
FeaturePlot(dataset.integrated, reduction = "pca", 
            features = c("nFeature_RNA","nCount_RNA","percent.mt"),
            dims =c(1,2),min.cutoff = "q1", max.cutoff = "q99")

DimPlot(dataset.integrated, reduction = "pca", group.by = "timepoint",dims=c(1,2))

DimPlot(dataset.integrated, reduction = "pca",group.by = "timepoint", dims=c(1,2),split.by = "timepoint")

```



## Step 9. Non-Linear Dimensionality Reduction


We visualize our data using the non-linear dimensionality reduction technique UMAP. This approach is analogous to PCA, but can also identify non-linear patterns in the data. The goal of the algorithm is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. UMAP is preferable to t-SNE as it is faster to compute, and uses a graph based approach that better preserves local and global components of the data. 

```{r umap, message = FALSE, warning = FALSE,eval = F} 

dataset.integrated <- RunUMAP(dataset.integrated, dims = 1:20,reduction = "pca")

DimPlot(dataset.integrated, reduction = "umap", group.by = "timepoint", pt.size = 1)
DimPlot(dataset.integrated, reduction = "umap", group.by = "timepoint",split.by = "timepoint", pt.size = 2, cols =  c("light grey", "cornflowerblue", "darkolivegreen3"))
dev.off()

FeaturePlot(dataset.integrated, reduction = "umap", 
            features = c("nFeature_RNA","nCount_RNA","percent.mt"),
            dims =c(1,2),min.cutoff = "q1", max.cutoff = "q99")

DimPlot(dataset.integrated, group.by = "phases",reduction = "umap",cols = cluster.cols) 
DimPlot(dataset.integrated, group.by = "orig.ident",reduction = "umap",split.by = "orig.ident") 

DimPlot(dataset.integrated,split.by = "timepoint",group.by = "timepoint")

```

## Step 10. Save the Seurat object

now we have done the pre-processing visualisation let's save the dataset to file 
```{r save_data, message = FALSE, warning = FALSE,eval = F} 
save(dataset.integrated,file = 'outputs/metadataset.Rda')
```




# Data QC Summary: 
In this experiment we have integrated V2 and V3 chemistries from 10X. We have performed preprocessing steps to remove cells with extreme UMI counts and mitochondrial content and have performed data normalisation and cell cycle classification. Superficially, based on PCA and UMAP plots the integration seems to have worked well. However we must bear this key technical difference in mind when drawing conclusions from subsequent analyses. It is also important in the following sections to know if we are using the integrated or original data in our analyses. Integrated data is useful for visualisation and data clustering but should not be used to perform  statistical comparisons as cells can no longer be considered independent. Where appropriate data from the RNA slot should be shown to make sure that our results are not an artefact of the integration



# Semi-supervised clustering and annotation of the data

## Step 11. Load the QC'd Seurat object

If you are not interested in reanalysing the QC steps you can start the analysis from here

```{r loaddata_object, message = FALSE, warning = FALSE} 

load('outputs/metadataset.Rda')


```

# Step 12. Density plots per age

To understand how the LSK compartment changes with age lets visualise the distribution of cells from our 3 timepoints. We will do this using our UMAP visualisation along with a density plot colouring scheme

```{r density_plot, message = FALSE, warning = FALSE} 

Idents(object = dataset.integrated) <- "timepoint"
young <- subset(dataset.integrated,idents = c("mo06"))
middle <- subset(dataset.integrated,idents = c("mo12"))
old <- subset(dataset.integrated,idents = c("mo18"))


p1 <- createDensityPlot(dataset.integrated,bins = 30)
p2 <- createDensityPlot(young, bins = 30)
p3 <- createDensityPlot(middle, bins = 30)
p4 <- createDensityPlot(old,bins = 30)


ggarrange(p1, p2,p3,p4,
          labels = c("All", "6mo", "12mo","18mo"),
          ncol = 2, nrow = 2)

DimPlot(dataset.integrated, reduction = "umap", group.by = "timepoint",split.by = "timepoint", pt.size = 2, cols =  c("light grey", "cornflowerblue", "darkolivegreen3"))

tiff(paste("/Users/jasoncosgrove/Desktop/UMAP.tiff",sep =""),width = 10, height = 8, units = 'in', res = 300)
DimPlot(dataset.integrated, reduction = "umap", group.by = "phases",split.by = "phases", pt.size = 2, cols =  c("light grey", "cornflowerblue", "darkolivegreen3","orange"))
dev.off()

```


## Step 13. Unsupervised clustering

To look at whether age affects a specific subcompartment of LSK cells we perform clustering using Seurats default approach. Briefly, this approach involves embedding cells in a graph structure such as a K-nearest neighbour graph, with edges drawn between cells with similar feature expression patterns, and then attempts to partition this graph into a number of highly interconnected subgroups. As LSK cells do not form discrete clusters, but rather show a smooth continuum of expression, our clustering results were highly sensitive to the resolution parameter of Seurats clustering algorithm. We cisualise the robustness of our clusters using the clustree visualistion tool

```{r unsupervised_clustering, message = FALSE, warning = FALSE} 

dataset.integrated <- FindNeighbors(object = dataset.integrated, 
                                      dims = 1:10,
                                      reduction = "pca",
                                      verbose = FALSE,force.recalc = TRUE)


for(i in seq(from=0.1, to=1.0, by=0.1)){
    dataset.integrated <- FindClusters(object = dataset.integrated, 
                                       resolution = i,verbose = F)
  }


tiff(paste("/Users/jasoncosgrove/Desktop/clustree.tiff",sep =""),width = 8, height = 10, units = 'in', res = 300)
clustree(dataset.integrated)
dev.off()


```

In this analysis we select 0.3 as a resolution parameter for downstream analysis which gives a total of 11 clusters. 

## Step 14. Visualise clustering and Assessing Cluster Composition. 

```{r analyseClusters, message = FALSE, warning = FALSE}

dataset.integrated <- FindClusters(dataset.integrated,resolution=0.3,force.recalc = TRUE,
                                   verbose = FALSE)

dataset.integrated@meta.data$cluster <- dataset.integrated @meta.data$integrated_snn_res.0.3

cluster.cols <- c("light grey", "cornflowerblue", "darkolivegreen3", "plum","dark red","dark green","red","dark blue","grey10","grey50","orange")


DimPlot(dataset.integrated,pt.size = 1,reduction = "umap", cols =  cluster.cols)


df <- (table( dataset.integrated@meta.data$integrated_snn_res.0.3,
              dataset.integrated@meta.data$timepoint))
opar <- par(lwd = 4)
barplot(t(t(df) /colSums(df)),legend = FALSE, col =  cluster.cols)


#check the cell cycle distribution across clusters also.
#In this plot green is S-phase, blue is G2m, and G1 is in grey
df <- (table(dataset.integrated@meta.data$phases, dataset.integrated@meta.data$integrated_snn_res.0.3))
opar <- par(lwd = 4)
barplot(t(t(df) /colSums(df)),legend = FALSE, col =  cluster.cols)

```

Is there some technical artefact that could explain our clustering results? This is important because the 6 month timepoint is with the V2 chemistry of 10X so we get less UMIs and genes per cell

```{r analyseClustersTechnical, message = FALSE, warning = FALSE}
#Make sure to use the RNA slot here and not the integrated. 
VlnPlot(dataset.integrated,c("nCount_RNA","nFeature_RNA","percent.mt"),cols = cluster.cols,assay = 'RNA')

```

## Step 15. Identification of Differentially Expressed Genes Between Clusters 

To understand between key differences between our clusters, we perform a differential expression analysis. It is important to note that different approaches for differential expression analysis of single cells rely on different assumptions about that data, and consequently can give very different results5. To address this limitation we use two different, but complementary, approaches: edgeR and logistic regression. 

In the approach below we employ a logistic regression framework to determine differentially expressed genes. Specifically, we construct a logistic regression model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test. This approach is advantageous for the analysis of HSPCs  have an expression profile that is distinct from mature cell subsets. Typically, expression profiles are bimodal, and changes in the magnitude of expression are subtle. In other datasets we have noted that cells have similar expression magnitudes but that different proportions of cells are positive for a given gene, within a given group. Given these unique features of our data, we posit that logistic regression is well suited to performing differential expression analysis of our data.

```{r findClusterMarkers, message = FALSE, warning = FALSE}



DefaultAssay(dataset.integrated) <- "RNA" #make sure you work with the RNA slot when you are making statistical comparisons


x <- FindAllMarkers(dataset.integrated, test.use = "LR",only.pos = TRUE,logfc.threshold = 0.2)


x %>%
    group_by(cluster) %>%
    top_n(n = 5, wt = avg_log2FC) -> top10


top10.filtered <- top10[as.numeric(top10$cluster) > 6,]


DotPlot(dataset.integrated, features = unique(top10$gene)) + RotatedAxis()



```


## Step 16. Assess the expression of known lineage marker genes across our different clusters


```{r lineageMarkers, message = FALSE, warning = FALSE} 

HSC.markers <- c("Procr","Ly6a")
neu.mo <- c("Ctsg","Mpo","Csf1r","Irf8","Cebpe")
meg <- c("Itga2b","Pbx1","Sdpr","Vwf","Sdha","F2lr2","Pf4","Selp")
ery <- c('Gata1', 'Klf1', 'Epor', 'Gypa', 'Hba-a2', 'Hba-a1')
ly <- c("Cd19","Vpreb2","Cd79a","Il7r","Cd79b")
mast.baso <- c("Ms4a2","Fcer1a","Cpa3","Gzmb","Mcpt8","Prss34")
MP.markers <- c("Cd34",
                'Fcer1g')
aged.markers <- c('Klf5', 'Ikzf1', 'Stat3')

VlnPlot(dataset.integrated, features = HSC.markers,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")


VlnPlot(dataset.integrated, features = neu.mo,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = meg,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = ery,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = ly,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = mast.baso,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = MP.markers,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

```

## Step 17. Assess the expression of known gene signatures across our different clusters

After fixing the resolution parameter, we then see  clusters overlap with previously described transcriptomic signatures.These signatures, along with associated references, are provided in a supplementary excel file.

```{r cluster_annotation_genesets, message = FALSE, warning = FALSE} 

gene.sets <- read.csv('inputs/genesets.csv')
gene.set.names <- colnames(gene.sets)
dataset.integrated <- geneSignatureScoring(dataset.integrated, gene.sets, gene.set.names,assay = "RNA")


VlnPlot(dataset.integrated, features = c("Pia_HSC1",
                                         "Pia_MPP11",
                                         "Pia_MPP21",
                                         "Pia_MPP31",
                                         "Pia_MPP41",
                                         "Pia_MPP51"),
        pt.size = 0,ncol = 2,
        cols = cluster.cols)



VlnPlot(dataset.integrated, features = c("WilsonMolO1",
                                          "MPP2_Pietras1",
                                          "MPP3_Pietras1"  ,
                                          "MPP4_Pietras1"),
        pt.size = 0,
        cols = cluster.cols)




VlnPlot(dataset.integrated, features = c("Yang_Lineage_Eryth1",
                                         "Yang_Granulocyte_Lineage1",  
                                         "Yang_Lineage_Lymphoid1"  ,  
                                         "Yang_Megakaryocyte_Lineage1"),
        pt.size = 0,
        cols = cluster.cols)




FeaturePlot(dataset.integrated,c("WilsonMolO1",
                                          "MPP2_Pietras1",
                                          "MPP3_Pietras1"  ,
                                          "MPP4_Pietras1"),min.cutoff = "q5",max.cutoff = "q95", cols  = c("grey95","black"))





FeaturePlot(dataset.integrated,c("WilsonMolO1",
                                   "Pia_MPP11",
                                         "Pia_MPP21",
                                         "Pia_MPP31",
                                         "Pia_MPP41",
                                         "Pia_MPP51"),min.cutoff = "q5",max.cutoff = "q95", cols  = c("grey95","black"),ncol = 3)



```


## Step 18. Cluster Annotation on young mice only

to make sure our interpretatio of the clustering is not biased by having so many aged LSKs we perform the same analysis but only on the young HSPCs
```{r genesetsYoungMice, message = FALSE, warning = FALSE} 

Idents(object = dataset.integrated) <- "timepoint"
young <- subset(dataset.integrated,idents = c("mo06"))
middle <- subset(dataset.integrated,idents = c("mo12"))
old <- subset(dataset.integrated,idents = c("mo18"))

Idents(dataset.integrated) <- "timepoint"

young <- subset(dataset.integrated,ident =  c("mo06"))


Idents(young) <- "cluster"
VlnPlot(young, features = HSC.markers,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")


VlnPlot(young, features = neu.mo,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(young, features = meg,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(young, features = ery,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(young, features = ly,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(young, features = mast.baso,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")


VlnPlot(young, features = c("Pia_HSC1",
                                         "Pia_MPP11",
                                         "Pia_MPP21",
                                         "Pia_MPP31",
                                         "Pia_MPP41",
                                         "Pia_MPP51"),
        pt.size = 0,
        cols = cluster.cols)



VlnPlot(young, features = c("WilsonMolO1",
                                          "MPP2_Pietras1",
                                          "MPP3_Pietras1"  ,
                                          "MPP4_Pietras1"),
        pt.size = 0,
        cols = cluster.cols)




VlnPlot(young, features = c("Yang_Lineage_Eryth1",
                                         "Yang_Granulocyte_Lineage1",  
                                         "Yang_Lineage_Lymphoid1"  ,  
                                         "Yang_Megakaryocyte_Lineage1"),
        pt.size = 0,
        cols = cluster.cols)


```



## Step 19. Reference-Based Cluster Annotation


Seurat v4 includes a set of methods to match  shared cell populations across datasets. These methods first identify cross-dataset pairs of cells that are in a matched biological state (‘anchors’) allowing us to perform supervised cell annotation. For label transfer you calculate the distance between reference anchors and query cells based on the PCA representation of the reference dataset. Cells are then assigned to a reference state based on their proximity to anchor cells. 

First lets load our reference dataset from Dahlin et al (2018) and double check that the cluster annotations used are sensible. 


```{r label_transfer, message = FALSE, warning = FALSE} 

#here is the code for seurat reference mapping
#https://satijalab.org/seurat/articles/integration_mapping.html

load("inputs/Dahlin.Rda") #dahlin dataset


dahlin <- RenameIdents(object = dahlin, 
                       `Stem` = "HSC",
                       `0` = "MPP",
                       `2` = "MPP",
                       `7` = "MPP",
                       `4` = "M",
                       `9` = "E/Mk")

#remove cluster 14 from the analysis
dahlin <- subset(dahlin,idents = '14',invert = TRUE)

dahlin.cols <- c("grey50","grey80","cornflowerblue","plum","orange","red","purple")

DimPlot(dahlin, cols = dahlin.cols)

VlnPlot(dahlin, features = HSC.markers,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")


VlnPlot(dahlin, features = neu.mo,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dahlin, features = meg,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dahlin, features = ery,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dahlin, features = ly,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dahlin, features = mast.baso,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

```


Now that we are sure that the cluster annotation is sensible lets run the label transfer

```{r label_transfer2, message = FALSE, warning = FALSE} 

#subset the data to take only the LSK cells
dahlin@meta.data$celltype <- dahlin@active.ident
Idents(dahlin) <- 'exp.groups'
reference <- subset(dahlin, idents = 1)

query <- dataset.integrated
DefaultAssay(object = query) <- "integrated"
reference <- FindVariableFeatures(reference,nfeatures = 2000)
reference <- ScaleData(reference)
query <- FindVariableFeatures(query,nfeatures = 2000)
query <- ScaleData(query)
genes <- intersect(rownames(reference),rownames(query))
anchors <- FindTransferAnchors(reference = reference, query = query, features = genes)
predictions <- TransferData(anchorset = anchors, refdata = reference@meta.data$celltype)
dataset.integrated <- AddMetaData(dataset.integrated, metadata = predictions)


DimPlot(dataset.integrated,group.by = 'predicted.id', cols =  c("red","plum","grey20","orange","cornflowerblue","purple","grey80"))


DimPlot(dataset.integrated,group.by = 'predicted.id', cols =  c("grey80","grey80","grey80","orange","grey80","grey80","grey80"))



DimPlot(dataset.integrated,group.by = 'predicted.id', cols =  c("grey80","grey80","grey80","grey80","cornflowerblue","grey80","grey80"))



DimPlot(dataset.integrated,group.by = 'predicted.id', cols =  c("red","grey80","grey80","grey80","grey80","grey80","grey80"))



DimPlot(dataset.integrated,group.by = 'predicted.id', cols =  c("grey80","grey80","grey80","grey80","grey80","purple","grey80"))


Idents(object = dataset.integrated) <- "timepoint"
young <- subset(dataset.integrated,idents = c("mo06"))
middle <- subset(dataset.integrated,idents = c("mo12"))
old <- subset(dataset.integrated,idents = c("mo18"))

young.results <- table(young@meta.data$predicted.id)
middle.aged.results <- table(middle@meta.data$predicted.id)
old.results <- table(old@meta.data$predicted.id)


df <- data.frame(t(rbind(young.results,middle.aged.results,old.results)))
df$celltype <- factor(rownames(df),levels = c('HSC', 'MPP', 'E/Mk', 'E', 'Mk', 'M',"L"))

df.ordered <- df %>% arrange(celltype) 
df.ordered <- df.ordered[,1:3]

colnames(df.ordered) <- c("6 months","12 months", "18 months")


opar <- par(lwd = 2)
barplot(t(t(df.ordered) /colSums(df.ordered)),legend = FALSE, col =  c("grey50","grey80","plum","red","purple","cornflowerblue","orange"))




Idents(dataset.integrated) <- 'cluster'
young.cluster.cells <- WhichCells(dataset.integrated, idents = c(0,1,2,4,5,6,9))
young <- subset(dataset.integrated,cells = young.cluster.cells)
aged.cluster.cells <- WhichCells(dataset.integrated, idents = c(3,7,8))
aged <- subset(dataset.integrated,cells = aged.cluster.cells)


df <- table(aged@meta.data$predicted.id)
opar <- par(lwd = 2)
barplot(t(t(df)/sum(df)), col = c("red","orange","cornflowerblue","purple","grey80"))




df <- table(aged@meta.data$predicted.id)
opar <- par(lwd = 2)
barplot(t(t(df)/sum(df)), col = c("red","orange","cornflowerblue","purple","grey80"))




```


# Data clustering summary: 

In this section we have used unsupervised clustering but parameterise and validate our clustering using information from the literature and by mapping onto a reference dataset. This semi-supervised approach suggests that there is a subset of HSCs, multipotent progenitors as well as a subset of cells that show evidence of lineage priming. We have also assessed our cluster annotations on young mice only, as much of our existing markers and signatures comes from young adults and not aged mice.  

3 clusters (3,7 and 8) are not found in young mice.  These clusters did not have lower UMI counts and genes than other clusters but cluster 3 did have lower mitochondrial percentage of reads. 

In the following section we will start to compare data across timepoints, using our clustering as a reference map for some of the key subpopulations of the LSK compartment


# Comparisons of LSKs across different ages

## Step 20. Cell Cycle Analysis

To assign a cell cycle phase to each cell, we use the cyclone method in the R package scran. In this scheme, a supervised learning approach was used to identify pairs of markers for each cell cycle phase. A G1 marker pair would comprise a gene with high expression in G1 relative to other phases, while the second gene would be lower in G1 relative to all other phases. To classify cell cycle phase on a new dataset, cyclone calculates the proportion of all marker pairs for  the expression of the first gene is higher than the second gene. A high proportion then suggests that the cell belongs to a given cell cycle phase. 


```{r cell_cycle2, message = FALSE, warning = FALSE} 


DimPlot(dataset.integrated,group.by = 'phases',split.by = "timepoint",
        cols = cluster.cols)



plotCellCycleDistribution <- function(sobj,other.var){
  
  df <- (table( sobj@meta.data$phases,sobj@meta.data[,other.var]))
opar <- par(lwd = 2)
barplot(t(t(df) /colSums(df)),legend = F, col =  cluster.cols)
}


Idents(object = dataset.integrated) <- "timepoint"
young <- subset(dataset.integrated,idents = c("mo06"))
middle <- subset(dataset.integrated,idents = c("mo12"))
old <- subset(dataset.integrated,idents = c("mo18"))

plotCellCycleDistribution(dataset.integrated,"timepoint")
plotCellCycleDistribution(dataset.integrated,"cluster")


tiff(paste("/Users/jasoncosgrove/Desktop/cellcycle.tiff",sep =""),width = 3, height = 8, units = 'in', res = 300)


par(mfrow=c(3,1), mai = c(0.3, 0.3, 0.3, 0.3))
plotCellCycleDistribution(young,"cluster")
plotCellCycleDistribution(middle,"cluster")
plotCellCycleDistribution(old,"cluster")
dev.off()

```



## Step 21. Identification of Differentially Expressed Genes Across Ages
To understand between key differences between our clusters, we perform a differential expression analysis. It is important to note that different approaches for differential expression analysis of single cells rely on different assumptions about that data, and consequently can give very different results5. To address this limitation we use two different, but complementary, approaches: edgeR and logistic regression. 

In the approach below we employ a logistic regression framework to determine differentially expressed genes. Specifically, we construct a logistic regression model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test. This approach is advantageous for the analysis of HSPCs  have an expression profile that is distinct from mature cell subsets. Typically, expression profiles are bimodal, and changes in the magnitude of expression are subtle. In other datasets we have noted that cells have similar expression magnitudes but that different proportions of cells are positive for a given gene, within a given group. Given these unique features of our data, we posit that logistic regression is well suited to performing differential expression analysis of our data.



```{r markers, message = FALSE, warning = FALSE} 

#################### do all cells #############################


Idents(dataset.integrated) <- "timepoint"
dataset.integrated@active.assay <- "RNA"
x <- FindAllMarkers(dataset.integrated, test.use = "LR",only.pos = TRUE, assay = "RNA",logfc.threshold = 0.2)

write.csv(x,"/Users/jasoncosgrove/Desktop/S13_clusters_for_diffages.csv")


x.filtered <- x[x$cluster == "mo18",]

dataset.integrated <- AddModuleScore(dataset.integrated,features =list(x.filtered$gene), name = "aged_sig")

VlnPlot(dataset.integrated,"aged_sig1",cols = cluster.cols,group.by = "cluster",pt.size = 0)




x %>%
    group_by(cluster) %>%
    top_n(n = 20, wt = avg_log2FC) -> top10




DotPlot(dataset.integrated, features = unique(top10$gene)) + RotatedAxis()








x <- FindMarkers(dataset.integrated,ident.1 = "mo06",ident.2 = c("mo12"),logfc.threshold = 0.2, test.use = "LR",only.pos = FALSE, assay = "RNA")
x.ordered <- x[order(x$avg_log2FC),]
genes <- c(tail(rownames(x.ordered),5),head(rownames(x.ordered),5))
avg <- as.data.frame(log1p(AverageExpression(dataset.integrated, verbose = FALSE)$RNA))
avg$gene <- rownames(avg)

genes.to.label = c(genes,"Aes","Kcnq1","Calr","Rbm3","mt-Nd3","mt-Nd1","mt-Nd4","Actb","mt-Atp6","Ndfip1","Lars2","Uba52","Hist1h2ap","Tomm6","Gas5",
                   'S100a8', 'S100a9', 'Mpo', 'Ltb',"Procr","Tcf15")
p1 <- ggplot(avg, aes(mo06, mo12)) + geom_point(colour = alpha("grey60",0.3)) + ggtitle("6 months vs 12 months") 
p1 <- LabelPoints(plot = p1, points = genes.to.label, repel = TRUE,xnudge = 0, ynudge = 0,size = 7,fontface = "bold",colour = "grey20")

p1 + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black",size = 1.2)) +theme(axis.text=element_text(size=15),
        axis.title=element_text(size=10,face="bold"))



x <- FindMarkers(dataset.integrated,ident.1 = "mo06",ident.2 = c("mo18"),logfc.threshold = 0.2, test.use = "LR",only.pos = FALSE, assay = "RNA")
x.ordered <- x[order(x$avg_log2FC),]
genes <- c(tail(rownames(x.ordered),5),head(rownames(x.ordered),3))
avg <- as.data.frame(log1p(AverageExpression(dataset.integrated, verbose = FALSE)$RNA))
avg$gene <- rownames(avg)


genes.to.label = c(genes,"Aes","Kcnq1","mt-Nd1","mt-Nd4","Actb","Ndfip1","Uba52","Hist1h2ap","Tomm6","Gas5","Erh","Snrpg","Elane","Fcer1g","Slpi","Psap","Lyz2","G6pdx",'Mpo', 'Ltb',"Procr") 
p2 <- ggplot(avg, aes(mo06, mo18)) + geom_point(colour = alpha("grey60",0.3)) + ggtitle("6 months vs 18 months") 
p2 <- LabelPoints(plot = p2, points = genes.to.label, repel = TRUE,xnudge = 0, ynudge = 0,size = 7,fontface = "bold",colour = "cornflowerblue")

p2 + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black",size = 1.2)) +theme(axis.text=element_text(size=15),
        axis.title=element_text(size=10,face="bold"))



  
x <- FindMarkers(dataset.integrated,ident.1 = "mo12",ident.2 = c("mo18"),logfc.threshold = 0.2, test.use = "LR",only.pos = FALSE, assay = "RNA")
x.ordered <- x[order(x$avg_log2FC),]
genes <- c(tail(rownames(x.ordered),10),head(rownames(x.ordered),10))
avg <- as.data.frame(log1p(AverageExpression(dataset.integrated, verbose = FALSE)$RNA))
avg$gene <- rownames(avg)




genes.to.label = unique(c(genes,"Ltf","G6pdx","Elane","Fcer1g","Slpi","Psap","Lyz2",'Mpo', 'Ltb'))
p3 <- ggplot(avg, aes(mo12, mo18)) + geom_point(colour = alpha("grey60",0.3)) + ggtitle("12 months vs 18 months") 
p3 <- LabelPoints(plot = p3, points = genes.to.label, repel = TRUE,xnudge = 0, ynudge = 0,size = 7,fontface = "bold",colour = "darkolivegreen4")

p3 + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black",size = 1.2)) +theme(axis.text=element_text(size=15),
        axis.title=element_text(size=10,face="bold"))


```




## Step 22. Check Lineage Markers and Gene Expression Across Ages

to make sure our interpretatio of the clustering is not biased by having so many aged LSKs we perform the same analysis but only on the young HSPCs
```{r MarkersAcrossAges, message = FALSE, warning = FALSE} 

Idents(object = dataset.integrated) <- "timepoint"

VlnPlot(dataset.integrated, features = HSC.markers,
          pt.size = 0,
        cols = cluster.cols,assay = "RNA")


VlnPlot(dataset.integrated, features = neu.mo,
          pt.size = 0,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = meg,
          pt.size = 0,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = ery,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = ly,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")

VlnPlot(dataset.integrated, features = mast.baso,
          pt.size = 0.1,
        cols = cluster.cols,assay = "RNA")


VlnPlot(dataset.integrated, features = c("Pia_HSC1",
                                         "Pia_MPP11",
                                         "Pia_MPP21",
                                         "Pia_MPP31",
                                         "Pia_MPP41",
                                         "Pia_MPP51"),
        pt.size = 0,
        cols = cluster.cols)



VlnPlot(dataset.integrated, features = c("WilsonMolO1",
                                          "MPP2_Pietras1",
                                          "MPP3_Pietras1"  ,
                                          "MPP4_Pietras1"),
        pt.size = 0,
        cols = cluster.cols)




VlnPlot(dataset.integrated, features = c("Yang_Lineage_Eryth1",
                                         "Yang_Granulocyte_Lineage1",  
                                         "Yang_Lineage_Lymphoid1"  ,  
                                         "Yang_Megakaryocyte_Lineage1"),
        pt.size = 0,
        cols = cluster.cols)


Idents(dataset.integrated) <- "cluster"
hsc.cells <- WhichCells(dataset.integrated, idents = c(0))
hsc <- subset(dataset.integrated,cells = hsc.cells)
VlnPlot(hsc, features = c("Yang_active_HSCs1","WilsonMolO1",
                            "Yang_Quiescent_HSCs1",
                            "Nina_dHSCs1",	"Nina_aHSCs1","Ly6a","Mki67"),
        pt.size = 0,
        cols = cluster.cols,group.by = "timepoint",assay = "RNA")

VlnPlot(dataset.integrated, features = c("Yang_active_HSCs1","WilsonMolO1",
                            "Yang_Quiescent_HSCs1",
                            "Nina_dHSCs1",	"Nina_aHSCs1","Ly6a","Mki67"),
        pt.size = 0.1,
        cols = cluster.cols,group.by = "timepoint",assay = "RNA")


#Leila gave me some additional gene sets to look at - to do incorporate this into genesets and then just send everything to outputs
aged.gene.sets <- read.csv("/Users/jasoncosgrove/Dropbox (Team_Perie)/Jason/Experiments/Dry_Lab/JCB18_DRAG_forUrbanus_et_al/leila_genesets.csv")


aged.gene.set.names <- colnames(aged.gene.sets)

geneSignatureScoring <- function(sobj,  gene.sets,gene.set.names,assay){
  
  for(i in 1:length(gene.set.names)){
    
    print(gene.set.names[i])
    genes.of.interest <- paste(gene.sets[,gene.set.names[i]])
    genes.of.interest <- genes.of.interest[genes.of.interest != ""]
    genes.of.interest <- intersect(genes.of.interest,rownames(sobj@assays$RNA))
    if(length(genes.of.interest) > 5){
    sobj <- AddModuleScore(sobj , features = list(genes.of.interest),
                           name = gene.set.names[i],replace = TRUE,assay = assay)
    }
  }
  
  return(sobj)
  
}


dataset.integrated <- geneSignatureScoring(dataset.integrated, aged.gene.sets, aged.gene.set.names,assay = "RNA")

names <- c(aged.gene.set.names,gene.set.names)

for(i in 3:55){ #the first two genesets dont have enough genes in our dataset
  print(i)
tiff(paste("outputs/UMAPs/",names[i],"_UMAP.tiff",sep =""))
#p <- VlnPlot(dataset.integrated,paste(names[i],"1",sep=""),group.by = "timepoint")
p <- FeaturePlot(dataset.integrated,paste(names[i],"1",sep=""),min.cutoff = "q3", max.cutoff = "q97")
print(p)
dev.off()
}




```


## Step 23. Pathway Analysis

Perform pathway analysis using the enrichR R package
see https://cran.r-project.org/web/packages/enrichR/vignettes/enrichR.html

```{r GSEA_enrichr, message = FALSE, warning = FALSE,eval = TRUE}


library(enrichR)

Idents(dataset.integrated) <- "timepoint"
dataset.integrated@active.assay <- "RNA"


DEenrichRPlot(
  dataset.integrated,
  ident.1 = "mo06",
  ident.2 = "mo12",
  balanced = TRUE,
  logfc.threshold = 0.1,
  assay = NULL,
  max.genes = 2000,
  test.use = "LR",
  p.val.cutoff = 0.05,
  cols = NULL,
  enrich.database = c("GO_Biological_Process_2018"),
  num.pathway = 25,
  return.gene.list = FALSE
)



pathways <- DEenrichRPlot(
  dataset.integrated,
  ident.1 = "mo06",
  ident.2 = "mo12",
  balanced = TRUE,
  logfc.threshold = 0.1,
  assay = NULL,
  max.genes = 2000,
  test.use = "LR",
  p.val.cutoff = 0.05,
  cols = NULL,
  enrich.database = c("GO_Biological_Process_2018"),
  num.pathway = 100,
  return.gene.list = TRUE
)

write.csv(pathways,"/Users/jasoncosgrove/Desktop/HSPC_pathways_6vs12.csv")




DEenrichRPlot(
  dataset.integrated,
  ident.1 = "mo06",
  ident.2 = "mo18",
  balanced = TRUE,
  logfc.threshold = 0.1,
  assay = NULL,
  max.genes = 2000,
  test.use = "LR",
  p.val.cutoff = 0.05,
  cols = NULL,
  enrich.database = c("GO_Biological_Process_2018"),
  num.pathway = 25,
  return.gene.list = FALSE
)



pathways <- DEenrichRPlot(
  dataset.integrated,
  ident.1 = "mo06",
  ident.2 = "mo18",
  balanced = TRUE,
  logfc.threshold = 0.1,
  assay = NULL,
  max.genes = 2000,
  test.use = "LR",
  p.val.cutoff = 0.05,
  cols = NULL,
  enrich.database = c("GO_Biological_Process_2018"),
  num.pathway = 100,
  return.gene.list = TRUE
)

write.csv(pathways,"/Users/jasoncosgrove/Desktop/HSPC_pathways_6vs18.csv")





pathways <- DEenrichRPlot(
  dataset.integrated,
  ident.1 = "mo12",
  ident.2 = "mo18",
  balanced = TRUE,
  logfc.threshold = 0.1,
  assay = NULL,
  max.genes = 2000,
  test.use = "LR",
  p.val.cutoff = 0.05,
  cols = NULL,
  enrich.database = c("GO_Biological_Process_2018"),
  num.pathway = 100,
  return.gene.list = TRUE
)

write.csv(pathways,"/Users/jasoncosgrove/Desktop/HSPC_pathways_12vs18.csv")




```






## Step 24. Diffusion Map
Do a diffusion map trajectory analysis using the destiny R package. More information about this method can be found at the following links:

https://academic.oup.com/bioinformatics/article/31/18/2989/241305?login=true

http://bioconductor.org/packages/release/bioc/html/destiny.html

```{r diffusion_map, message = FALSE, warning = FALSE} 

sobj <- dataset.integrated
DefaultAssay(object = sobj ) <- "integrated"
df <- as.matrix(sobj@assays$integrated@data)

df <- t(df)
sigmas <- find_sigmas(df, verbose = FALSE)
dm.combined <- DiffusionMap(df,sigma = optimal_sigma(sigmas),n_pcs = 10)

index <- which.max(sobj@meta.data$WilsonMolO1)
dpt <- DPT(dm.combined, tips = index)
sobj$pseudotime_dpt_ranked <- rank(dpt$dpt) 
sobj$pseudotime_dpt <- dpt$dpt

FeaturePlot(sobj,"pseudotime_dpt",min.cutoff = "q3", max.cutoff = "q97",pt.size = 1.5)

library(ggbeeswarm)
library(ggthemes)
df <- as.data.frame(sobj@meta.data)

df$cluster <- factor(df$cluster,levels = c("2","0","1","6","3",
                                           "5","4","9","7","10","8"))



cluster.cols <- c("light grey", "cornflowerblue", "darkolivegreen3", "plum","dark red","dark green","red","dark blue","grey10","grey50","orange")


new.cols <- c("darkolivegreen3","light grey","cornflowerblue","red","plum",
              "dark green","dark red","grey50","dark blue","orange","grey10")






  


ggplot(df, 
       aes(x = pseudotime_dpt_ranked, 
           y = cluster, colour = cluster)) + geom_quasirandom(groupOnX = FALSE) +
    scale_color_manual(values = new.cols) + theme_classic() +
    xlab("DPT") + ylab("Timepoint") +
    ggtitle("Cells ordered by pseudotime")


ggplot(df, 
       aes(x = pseudotime_dpt_ranked, 
           y = cluster, colour = cluster)) + geom_quasirandom(groupOnX = FALSE) +
    scale_color_manual(values = new.cols) + theme_classic() +
    xlab("DPT") + ylab("Timepoint") +
    ggtitle("Cells ordered by pseudotime")



ggplot(df, 
       aes(x = pseudotime_dpt_ranked, 
           y = timepoint, colour = timepoint)) + geom_quasirandom(groupOnX = FALSE) +
    scale_color_manual(values = cluster.cols) + theme_classic() +
    xlab("DPT") + ylab("Timepoint") +
    ggtitle("Cells ordered by pseudotime")


dmap.combined <- eigenvectors(dm.combined)[, 1:10]
rownames(dmap.combined) <- colnames(dataset.integrated)

sobj[["dmap"]] <- CreateDimReducObject(embeddings = dmap.combined, 
                                                        key = "DMAP", 
                                                        assay = 
                                              DefaultAssay(sobj ))

DimPlot(object = sobj, label = F,reduction = "dmap", pt.size = 0.5,dims = c(1,2),
        split.by = "timepoint",group.by = "timepoint")


```

# Final Summary

In this experiment we analysed LSKs from mice that were 6.5 ,12 (10X V3) and 19 months (10X V3) old. Data were integrated and underwent semi-supervised clustering and annotation. We then assessed clusters annd gene expression patterns that were upregulated at the different ages and modelled differentiation using a diffusion map based approach. 
